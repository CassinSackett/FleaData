# de novo genome assembly from PacBio HiFi (High Fidelity) long reads  :ant:

###### tags: `assembly`, `purge_dups`, `BUSCO`, `hifiasm`, `small`

> This pipeline was developed for mammal genomes and includes some steps that are necessary for assembling these larger (~3Gb) genomes but that may not be needed for smaller genomes. 
  
- Table of Contents
[ToC]


## Step 1: Run Hifiasm

The first step is to use the HiFiasm software to assemble a genome from the raw PacBio reads. (You'll start with the slurm part at the top, as always). Then, the general structure for assembly of heterozygous genomes is:

``` hifiasm -o prefix -t numberThreads input.fasta.gz --write-paf --write-ec /dev/null ```

so the whole script looks something like this

```
#!/bin/bash
#SBATCH -N 1
#SBATCH -n 48
#SBATCH -t 24:00:00
#SBATCH -o assembly_ORCAI-homcov19s25_022724.out 
#SBATCH -e assembly_ORCAI-homcov19s25_022724.err

#I installed HiFiasm via anaconda
source sackettl/miniconda3/etc/profile.d/conda.sh
source activate hifiasm_env 

cd /sackettl/squirrels/ORCA_GMGS/

hifiasm -o ORCAI-homcov19s25v2 -t 44 purge_dups-1.2.6/m64086e_230206_201241.hifi_reads.fasta.gz purge_dups-1.2.6/m64086e_230210_154702.hifi_reads.fasta.gz purge_dups-1.2.6/m64086e_230212_010601.hifi_reads.fasta.gz --hom-cov 19 -s 0.25 --write-paf --write-ec /dev/null

#get primary contigs in FASTA
awk '/^S/{print ">"$2;print $3}' ORCAI-homcov19s25v2.bp.p_ctg.gfa > ORCAI-homcov19s25v2.p_ctg.fa

```
The last line is to translate the HiFiasm results to a fasta assembly, which is what you will want for most downstream processes.

---


## Step 2: Re-run HiFiasm with different parameters and compare the quality of the assembly

You want to end up with an assembly that is close to the expected genome size and has the largest scaffold N50 and smallest number of scaffolds that you can achieve. Different combinations of parameters (e.g., s, D) can help you optimize the assembly quality.

You should also check the quality of each assembly with busco and assembly_stats and compare their outputs.


### 2a. Evaluate assembly with Busco
First, evaluate with busco using the correct database for your taxon:

```
#!/bin/bash
#SBATCH -N 1
#SBATCH -n 48
#SBATCH -t 12:00:00
#SBATCH -o busco_ORCAI-homcov19s25D10_041823.out 
#SBATCH -e busco_ORCAI-homcov19s25D10_041823.err

# I ran busco from its own conda environment
source /sackettl/miniconda3/etc/profile.d/conda.sh
conda activate busco5_env 
#source activate busco_env

#depending on how busco installs, you may need to use 'python run_BUSCO.py' and then the command
busco -i /sackettl/squirrels/ORCA_homcov19s25D10/ORCAI-homcov19s25D10.p_ctg.fa \
        -l mammalia_odb10 -c 44 -m genome -o ORCAI-homcov19s25D10_busco -f

```

### 2b. Evaluate assembly with assembly_stats
Next, evaluate your assembly using assembly_stats, which you can also install using anaconda:

```
#!/bin/bash
#SBATCH -N 1
#SBATCH -n 20
#SBATCH -t 1:30:00
#SBATCH -o assemblystats_ORCAI-homcov19s25D10_041823.out 
#SBATCH -e assemblystats_ORCAI-homcov1925D10_041823.err

source /sackettl/miniconda3/etc/profile.d/conda.sh
conda activate assemblystats_env

assembly-stats /sackettl/squirrels/ORCA_homcov19s25D10/ORCAI-homcov19s25D10.p_ctg.fa > ORCAI-homcov19s25D10_assembly-stats.out

```

Based on the busco scores and assembly stats for each variation of the assembly, you can choose the best one for use in purge_dups.

---

## Step 3: Run purge_dups to improve the assembly

This mini-pipeline is based off the [suggested pipeline for purge_dups](https://github.com/dfguan/purge_dups?tab=readme-ov-file#pplg) and starts with the genome generated by HiFiasm above.

### 3a. Generate an alignment
First, we need to map the raw PacBio HiFi reads to the draft genome from HiFiasm. We will use [minimap2](https://lh3.github.io/minimap2/minimap2.html) with the asm20 mapping (map-hifi is not available as part of the purge_dups conda package).

```
#SBATCH lines

export JOBS_PER_NODE=44

source /miniconda3/etc/profile.d/conda.sh
conda activate purgedups126_ENV

cd /sackettl/ORCA_GMGS/

for i in purge_dups-1.2.6/*fasta.gz; do minimap2 -I 10G -x asm20 -t 46 working-assembly/ORCA-homcov19s25l2.p_ctg.fa $i > $i.asm20.paf; done

pbcstat purge_dups-1.2.6/*asm20.paf
calcuts PB.stat > automatic.cutoffs 2>calcuts_auto.log

```
The ```pbcstat``` step will generate PB.base.cov and PB.stat files. I rename these with the alignment parameters, like PB.base.asm20.cov, since I will be trying multiple alignment methods and cutoff values.

:white_flower: :sunflower: :arrow_down: 
I wanted to check the asm20 mapping results with the results of ```minimap -x map-hifi```, so I did a separate installation of minimap 2 with

```
git clone https://github.com/lh3/minimap2
cd minimap2 && make
```

and then ran the mapping step again with the same command as previously except with  hifi mapping:

```
for i in purge_dups-1.2.6/*fasta.gz; do /project/sackettl/software/minimap2/minimap2 -I 10G -x map-hifi -t 46 working-assembly/ORCAI-homcov19s25l2.p_ctg.fa $i > $i.HiFi.paf; done
```

:white_flower: :sunflower: :arrow_heading_up: 

### 3b. Visualize the coverage histogram
Now we need to look at the histogram of read coverage using the alignment of our reads to our draft genome. It is possible that the manually generated cutoffs are fine, but I got error messages from the calcuts step and had to create my own.

```
#SBATCH lines

export JOBS_PER_NODE=44

source /miniconda3/etc/profile.d/conda.sh
conda activate purgedups126_ENV

cd /sackettl/ORCA_GMGS/

pip install matplotlib

python3 ../purge_dups-1.2.6/scripts/hist_plot.py -c ORCA-homcov19s25l2_manual_l2m13u59.cutoffs PB.asm20.stat PB.cov.asm20_cut2-13-59.png 
```

Now download this to your computer with scp and take a look at it. It should look something like this
![PB.cov.asm20_cut1-14-65](https://hackmd.io/_uploads/ry85d8qs0.png)

There is some guidance on how to set the thresholds for your data [here](https://github.com/dfguan/purge_dups/issues/14), and you should trust the purge_dups authors' recommendations over mine. :smiley:  Essentially, you want to find the lower limit of coverage that you think represents junk (things that were sequenced at very low coverage), which is the point at the far-left side of the plot before the histogram line starts to increase. In my data, I compared results with ```-l1``` and ```-l2``` and ultimately decided on a lower cutoff of 1. For the middle threshold, you want to look for the valley if you have two peaks. After running some trials, I chose ```-m12``` which looked sort of like an inflection point to me. The upper regionsi of the coverage plot represent repeated regions, but choosing the upper threshold seems less straightforward to me. In many examples presented by users [here](https://github.com/dfguan/purge_dups/issues/14), the suggested upper threshold was >200. Since my plot did not go that high, and the automatic cutoffs chose something really small (45), I opted for an upper limit of around 60. You should try some values and then check the busco scores to evaluate both the percent duplicated buscos and missing buscos (to make sure you don't purge too much).


### 3c. Set your cutoffs manually
You will likely have to change the cutoffs to some other values - either because of an error using the automatic cutoffs or to explore the results of different degrees of purging. This just requires flags for lower, middle, and upper cutoffs:

```
calcuts -l 1 -m 12 -u 55 PB.asm20.stat > ORCA-homcov19s25l2_manual_l1m12u55.cutoffs 2> calcuts_manual-l1m12u55_asm20.log 

```

### 3d. Split your assembly

```
split_fa ../working-assembly/ORCAI-homcov19s25l2.p_ctg.fa > ORCAI-homcov19s25l2.p_ctg.fa.split

minimap2 -xasm10 -DP ORCAI-homcov19s25l2.p_ctg.fa.split ORCAI-homcov19s25l2.p_ctg.fa.split | gzip -c - > ORCAI-homcov19s25l2.p_ctg.fa.split.self.asm10.paf.gz
```

### 3e. Now you can purge!
Now that you have determined what the appropriate levels of purging *may* be (but check the results of multiple, because you still won't know for sure!), you can purge the duplicates and junk, and keep the rest. You do so in these two steps:

```
purge_dups -2 -T ORCA-homcov19s25l2_manual_l1m12u55.cutoffs -c PB.base.asm20.cov ORCAI-homcov19s25l2.p_ctg.fa.split.self.paf.gz > ORCA-homcov19s25l2_manualcutoffs-l1m12u55_asm20_dups.bed 2> ORCA-homcov19s25l2_manualcutoffs-l1m12u55_asm20_purge_dups.log

get_seqs -e ORCA-homcov19s25l2_manualcutoffs-l1m12u55_asm20_dups.bed ../working-assembly/ORCAI-homcov19s25l2.p_ctg.fa

```

This will produce two output files: one called purge.fa, which is your purged assembly, and another called hap.fa, which is the removed scaffolds with a tag stating the reason they were removed (OVLP, REPEAT, etc.).


## Step 4: Evaluate your assemblies
You should check each assembly with assemblystats and busco as in Step 2. 




---


